# íŒ€2: ì‹¤ìŠµ ë¬¸ì œ ìƒì„± êµ¬í˜„ ê°€ì´ë“œ

**í”„ë¡œì íŠ¸**: EduMentor AI
**ë‹´ë‹¹**: íŒ€2 (2ëª…)
**ê¸°ê°„**: 2ì£¼
**ëª©í‘œ**: í•™ìŠµìë£Œ ê¸°ë°˜ ë‚œì´ë„ë³„(ì´ˆê¸‰/ì¤‘ê¸‰/ê³ ê¸‰) ì‹¤ìŠµ ë¬¸ì œ ìë™ ìƒì„±

---

## ğŸ“‹ íŒ€2 ì—­í•  ë¶„ë‹´

| ê°œë°œì | ë‹´ë‹¹ ê¸°ëŠ¥ | ì˜ˆìƒ ì‹œê°„ |
|--------|----------|-----------|
| **ê°œë°œì C** | ë‚œì´ë„ ë¶„ì„, í•™ìŠµ ë‚´ìš© ì¶”ì¶œ, LangGraph Agent êµ¬ì¡° | 5ì¼ |
| **ê°œë°œì D** | ë¬¸ì œ ìƒì„± ë¡œì§, ê²€ì¦, ë‹µì•ˆ ë° íŒíŠ¸ ìƒì„± | 5ì¼ |

---

## ğŸ¯ í•µì‹¬ ìš”êµ¬ì‚¬í•­

| ìš”êµ¬ì‚¬í•­ | ëª©í‘œ | ê²€ì¦ ë°©ë²• |
|----------|------|-----------|
| **ë‚œì´ë„ êµ¬ë¶„** | ì´ˆê¸‰/ì¤‘ê¸‰/ê³ ê¸‰ 3ë‹¨ê³„ | ë¬¸ì œ ë‚œì´ë„ ì ìˆ˜ ê²€ì¦ |
| **ë¬¸ì œ ìœ í˜•** | ì½”ë”©, ì„œìˆ í˜• | ë¬¸ì œ íƒ€ì… í•„ë“œ í™•ì¸ |
| **ìë™ ë‹µì•ˆ** | ëª¨ë“  ë¬¸ì œì— ì •ë‹µ í¬í•¨ | ë‹µì•ˆ ëˆ„ë½ ì²´í¬ |
| **íŒíŠ¸ ì œê³µ** | ë¬¸ì œë‹¹ 2ê°œ ì´ìƒ íŒíŠ¸ | íŒíŠ¸ ê°œìˆ˜ ê²€ì¦ |
| **í•™ìŠµìë£Œ ê¸°ë°˜** | ChromaDBì—ì„œ ë‚´ìš© ì¶”ì¶œ | ì¶œì²˜ í˜ì´ì§€ ëª…ì‹œ |
| **LangGraph** | Agent ì›Œí¬í”Œë¡œìš° | ë‹¤ì´ì–´ê·¸ë¨ ì‘ì„± |

---

## Week 1: ê¸°ë°˜ êµ¬ì¶•

### Day 1: í™˜ê²½ ì„¤ì • ë° í”„ë¡œì íŠ¸ êµ¬ì¡°

#### ê°œë°œì C + D (ê³µë™ ì‘ì—…)

**1.1 Python í”„ë¡œì íŠ¸ ìƒì„±**

```bash
# í”„ë¡œì íŠ¸ êµ¬ì¡°
team2_problem/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ config.py              # ì„¤ì •
â”œâ”€â”€ models.py              # Pydantic ëª¨ë¸
â”œâ”€â”€ workflow.py            # LangGraph ì›Œí¬í”Œë¡œìš°
â”œâ”€â”€ api.py                 # FastAPI ì—”ë“œí¬ì¸íŠ¸
â”œâ”€â”€ generators/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ beginner.py        # ì´ˆê¸‰ ë¬¸ì œ ìƒì„±
â”‚   â”œâ”€â”€ intermediate.py    # ì¤‘ê¸‰ ë¬¸ì œ ìƒì„±
â”‚   â””â”€â”€ advanced.py        # ê³ ê¸‰ ë¬¸ì œ ìƒì„±
â”œâ”€â”€ validators/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ problem_validator.py
â””â”€â”€ utils/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ upstage_client.py  # íŒ€1ê³¼ ê³µìœ 
    â””â”€â”€ chroma_client.py   # íŒ€1ê³¼ ê³µìœ 
```

**1.2 ì˜ì¡´ì„± ì„¤ì¹˜**

```bash
# íŒ€1ê³¼ ë™ì¼í•œ requirements.txt ì‚¬ìš©
pip install -r requirements.txt
```

**1.3 Pydantic ëª¨ë¸ ì •ì˜**

```python
# models.py
from pydantic import BaseModel
from typing import List, Dict, Literal, Optional

class Problem(BaseModel):
    """ë¬¸ì œ ëª¨ë¸"""
    question: str
    answer: str
    hints: List[str]
    difficulty_score: int  # 1-10
    problem_type: Literal["CODING", "SHORT_ANSWER", "MULTIPLE_CHOICE"]
    test_cases: Optional[List[Dict]] = []
    source_pages: List[int] = []

class ProblemRequest(BaseModel):
    """ë¬¸ì œ ìƒì„± ìš”ì²­"""
    material_id: int
    difficulty: Literal["BEGINNER", "INTERMEDIATE", "ADVANCED"]
    problem_count: int = 3
    problem_type: Optional[str] = None  # íŠ¹ì • ìœ í˜• ìš”ì²­

class ProblemResponse(BaseModel):
    """ë¬¸ì œ ìƒì„± ì‘ë‹µ"""
    problems: List[Problem]
    difficulty: str
    generated_count: int
    rejected_count: int
```

---

### Day 2-3: í•™ìŠµ ë‚´ìš© ë¶„ì„ ë° ì¶”ì¶œ (ê°œë°œì C)

**2.1 í•™ìŠµ ë‚´ìš© ë¶„ì„ê¸°**

```python
# utils/content_analyzer.py
from typing import List, Dict
from utils.chroma_client import chroma_client
import logging

logger = logging.getLogger(__name__)

class ContentAnalyzer:
    """í•™ìŠµìë£Œ ë¶„ì„ ë° í•µì‹¬ ê°œë… ì¶”ì¶œ"""

    async def analyze_material(
        self,
        material_id: int,
        difficulty: str
    ) -> Dict:
        """ë‚œì´ë„ì— ë§ëŠ” í•™ìŠµ ë‚´ìš© ì¶”ì¶œ"""

        # ë‚œì´ë„ë³„ ê²€ìƒ‰ ì „ëµ
        search_strategies = {
            "BEGINNER": {
                "keywords": ["ê¸°ë³¸", "ê°œë…", "ì •ì˜", "ì˜ˆì œ", "ì†Œê°œ"],
                "k": 5,
                "focus": "fundamental"
            },
            "INTERMEDIATE": {
                "keywords": ["ì‹¤ìŠµ", "êµ¬í˜„", "í™œìš©", "ì‘ìš©", "ì˜ˆì œ"],
                "k": 7,
                "focus": "practical"
            },
            "ADVANCED": {
                "keywords": ["ì‹¬í™”", "ìµœì í™”", "ì„¤ê³„", "ë³µì¡í•œ", "ê³ ê¸‰"],
                "k": 10,
                "focus": "advanced"
            }
        }

        strategy = search_strategies[difficulty]

        # í‚¤ì›Œë“œë³„ ê²€ìƒ‰
        all_docs = []
        seen_ids = set()

        for keyword in strategy["keywords"]:
            results = chroma_client.search(
                collection_name="learning_materials",
                query_texts=[keyword],
                n_results=strategy["k"],
                filter_dict={"material_id": material_id}
            )

            # ì¤‘ë³µ ì œê±°í•˜ë©° ìˆ˜ì§‘
            for i, doc_id in enumerate(results.get('ids', [[]])[0]):
                if doc_id not in seen_ids:
                    seen_ids.add(doc_id)
                    all_docs.append({
                        'content': results['documents'][0][i],
                        'page': results['metadatas'][0][i]['page'],
                        'type': results['metadatas'][0][i]['type']
                    })

        logger.info(f"Extracted {len(all_docs)} content blocks for {difficulty}")

        return {
            "documents": all_docs,
            "strategy": strategy,
            "total_count": len(all_docs)
        }

    def extract_key_concepts(self, documents: List[Dict]) -> List[str]:
        """í•µì‹¬ ê°œë… ì¶”ì¶œ"""
        # ê°„ë‹¨í•œ í‚¤ì›Œë“œ ì¶”ì¶œ (ì‹¤ì œë¡œëŠ” NER ë“± ì‚¬ìš© ê°€ëŠ¥)
        concepts = set()

        for doc in documents:
            content = doc['content']
            # ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ ì¶”ì¶œ (í´ë˜ìŠ¤ëª…, ê°œë…ëª… ë“±)
            words = content.split()
            for word in words:
                if word[0].isupper() and len(word) > 3:
                    concepts.add(word)

        return list(concepts)[:10]  # ìƒìœ„ 10ê°œ

content_analyzer = ContentAnalyzer()
```

**2.2 ë‚œì´ë„ë³„ ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±**

```python
# generators/context_builder.py
from typing import List, Dict

class ContextBuilder:
    """ë¬¸ì œ ìƒì„±ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±"""

    def build_context(
        self,
        documents: List[Dict],
        difficulty: str,
        max_tokens: int = 3000
    ) -> str:
        """ë‚œì´ë„ì— ë§ëŠ” ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±"""

        context_parts = []
        current_tokens = 0

        for doc in documents:
            # ëŒ€ëµì ì¸ í† í° ê³„ì‚° (4 chars â‰ˆ 1 token)
            doc_tokens = len(doc['content']) // 4

            if current_tokens + doc_tokens > max_tokens:
                break

            context_parts.append(
                f"[í˜ì´ì§€ {doc['page']}]\n{doc['content']}"
            )
            current_tokens += doc_tokens

        context = "\n\n---\n\n".join(context_parts)

        return context

context_builder = ContextBuilder()
```

---

### Day 4-5: ë¬¸ì œ ìƒì„± ë¡œì§ (ê°œë°œì D)

**3.1 ì´ˆê¸‰ ë¬¸ì œ ìƒì„±ê¸°**

```python
# generators/beginner.py
from langchain_upstage import ChatUpstage
from langchain.schema import HumanMessage
from typing import List
from models import Problem
from config import settings
import json
import logging

logger = logging.getLogger(__name__)

class BeginnerProblemGenerator:
    """ì´ˆê¸‰ ì‹¤ìŠµ ë¬¸ì œ ìƒì„±"""

    def __init__(self):
        self.llm = ChatUpstage(
            api_key=settings.UPSTAGE_API_KEY,
            model="solar-1-mini-chat",
            temperature=0.7
        )

    async def generate(
        self,
        context: str,
        count: int = 3
    ) -> List[Problem]:
        """ì´ˆê¸‰ ë¬¸ì œ ìƒì„±"""

        prompt = f"""ë‹¤ìŒ í•™ìŠµ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ **ì´ˆê¸‰** ì‹¤ìŠµ ë¬¸ì œë¥¼ {count}ê°œ ìƒì„±í•˜ì„¸ìš”.

**í•™ìŠµ ë‚´ìš©**:
{context}

**ì´ˆê¸‰ ë¬¸ì œ ìš”êµ¬ì‚¬í•­**:
1. ê¸°ë³¸ ê°œë… ì´í•´ í™•ì¸
2. ë‹¨ìˆœí•œ ì½”ë“œ ì‘ì„± (5-10ì¤„)
3. ëª…í™•í•œ ì •ë‹µì´ ìˆëŠ” ë¬¸ì œ
4. ì‹¤ì œ í•™ìŠµ ë‚´ìš©ì—ì„œ ë‹¤ë£¬ ë‚´ìš©ë§Œ ì‚¬ìš©

**ì¶œë ¥ í˜•ì‹** (JSON):
[
    {{
        "question": "ë¬¸ì œ ë‚´ìš© (êµ¬ì²´ì ìœ¼ë¡œ)",
        "answer": "ì •ë‹µ ë˜ëŠ” ì˜ˆì‹œ ì½”ë“œ",
        "hints": ["íŒíŠ¸1", "íŒíŠ¸2"],
        "difficulty_score": 1-3 (1ì´ ê°€ì¥ ì‰¬ì›€),
        "problem_type": "CODING" ë˜ëŠ” "SHORT_ANSWER",
        "test_cases": [{{"input": "...", "expected": "..."}}]  // CODINGì¸ ê²½ìš°ë§Œ
    }},
    ...
]

**ì¤‘ìš”**: ë°˜ë“œì‹œ ìœ íš¨í•œ JSON ë°°ì—´ë¡œ ì¶œë ¥í•˜ì„¸ìš”."""

        response = await self.llm.ainvoke([HumanMessage(content=prompt)])

        try:
            problems_data = json.loads(response.content)
            problems = [Problem(**p) for p in problems_data]
            logger.info(f"Generated {len(problems)} beginner problems")
            return problems
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON: {e}")
            logger.error(f"Response: {response.content}")
            return []

beginner_generator = BeginnerProblemGenerator()
```

**3.2 ì¤‘ê¸‰ ë¬¸ì œ ìƒì„±ê¸°**

```python
# generators/intermediate.py
from langchain_upstage import ChatUpstage
from langchain.schema import HumanMessage
from typing import List
from models import Problem
from config import settings
import json
import logging

logger = logging.getLogger(__name__)

class IntermediateProblemGenerator:
    """ì¤‘ê¸‰ ì‹¤ìŠµ ë¬¸ì œ ìƒì„±"""

    def __init__(self):
        self.llm = ChatUpstage(
            api_key=settings.UPSTAGE_API_KEY,
            model="solar-1-mini-chat",
            temperature=0.8  # ë” ë‹¤ì–‘í•œ ë¬¸ì œ ìƒì„±
        )

    async def generate(
        self,
        context: str,
        count: int = 3
    ) -> List[Problem]:
        """ì¤‘ê¸‰ ë¬¸ì œ ìƒì„±"""

        prompt = f"""ë‹¤ìŒ í•™ìŠµ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ **ì¤‘ê¸‰** ì‹¤ìŠµ ë¬¸ì œë¥¼ {count}ê°œ ìƒì„±í•˜ì„¸ìš”.

**í•™ìŠµ ë‚´ìš©**:
{context}

**ì¤‘ê¸‰ ë¬¸ì œ ìš”êµ¬ì‚¬í•­**:
1. ì—¬ëŸ¬ ê°œë…ì„ ê²°í•©
2. ì‹¤ë¬´ ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜
3. ì½”ë“œ ì‘ì„± (20-30ì¤„)
4. í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ í¬í•¨
5. í•™ìŠµ ë‚´ìš©ì—ì„œ ë‹¤ë£¬ ê°œë…ë§Œ ì‚¬ìš©

**ì¶œë ¥ í˜•ì‹** (JSON):
[
    {{
        "question": "ì‹¤ë¬´ ìƒí™©ì„ ë°˜ì˜í•œ ë¬¸ì œ ë‚´ìš©",
        "answer": "ì •ë‹µ ì½”ë“œ ë˜ëŠ” ì„¤ëª…",
        "hints": ["íŒíŠ¸1 (ì²« ë‹¨ê³„)", "íŒíŠ¸2 (í•µì‹¬ ê°œë…)"],
        "difficulty_score": 4-6,
        "problem_type": "CODING",
        "test_cases": [
            {{"input": "...", "expected": "..."}},
            {{"input": "...", "expected": "..."}}
        ]
    }},
    ...
]

**ì¤‘ìš”**: ë°˜ë“œì‹œ ìœ íš¨í•œ JSON ë°°ì—´ë¡œ ì¶œë ¥í•˜ì„¸ìš”."""

        response = await self.llm.ainvoke([HumanMessage(content=prompt)])

        try:
            problems_data = json.loads(response.content)
            problems = [Problem(**p) for p in problems_data]
            logger.info(f"Generated {len(problems)} intermediate problems")
            return problems
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON: {e}")
            return []

intermediate_generator = IntermediateProblemGenerator()
```

**3.3 ê³ ê¸‰ ë¬¸ì œ ìƒì„±ê¸°**

```python
# generators/advanced.py
from langchain_upstage import ChatUpstage
from langchain.schema import HumanMessage
from typing import List
from models import Problem
from config import settings
import json
import logging

logger = logging.getLogger(__name__)

class AdvancedProblemGenerator:
    """ê³ ê¸‰ ì‹¤ìŠµ ë¬¸ì œ ìƒì„±"""

    def __init__(self):
        self.llm = ChatUpstage(
            api_key=settings.UPSTAGE_API_KEY,
            model="solar-1-mini-chat",  # ë˜ëŠ” solar-1-pro-chat
            temperature=0.9  # ì°½ì˜ì ì¸ ë¬¸ì œ ìƒì„±
        )

    async def generate(
        self,
        context: str,
        count: int = 3
    ) -> List[Problem]:
        """ê³ ê¸‰ ë¬¸ì œ ìƒì„±"""

        prompt = f"""ë‹¤ìŒ í•™ìŠµ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ **ê³ ê¸‰** ì‹¤ìŠµ ë¬¸ì œë¥¼ {count}ê°œ ìƒì„±í•˜ì„¸ìš”.

**í•™ìŠµ ë‚´ìš©**:
{context}

**ê³ ê¸‰ ë¬¸ì œ ìš”êµ¬ì‚¬í•­**:
1. ë³µì¡í•œ ì‹¤ë¬´ ì‹œë‚˜ë¦¬ì˜¤
2. ìµœì í™” ë˜ëŠ” ì„¤ê³„ ë¬¸ì œ
3. ì—¬ëŸ¬ íŒŒì¼/í´ë˜ìŠ¤ êµ¬ì„± í•„ìš”
4. ì—£ì§€ ì¼€ì´ìŠ¤ ê³ ë ¤
5. ì„±ëŠ¥ ë° í™•ì¥ì„± ê³ ë ¤

**ì¶œë ¥ í˜•ì‹** (JSON):
[
    {{
        "question": "ë³µì¡í•œ ì‹¤ë¬´ ì‹œë‚˜ë¦¬ì˜¤ ë¬¸ì œ",
        "answer": "ì •ë‹µ ì½”ë“œ ë˜ëŠ” ì„¤ê³„ ì„¤ëª…",
        "hints": ["íŒíŠ¸1 (ì•„í‚¤í…ì²˜ íŒíŠ¸)", "íŒíŠ¸2 (ìµœì í™” íŒíŠ¸)"],
        "difficulty_score": 7-10,
        "problem_type": "CODING",
        "test_cases": [
            {{"input": "ì¼ë°˜ ì¼€ì´ìŠ¤", "expected": "..."}},
            {{"input": "ì—£ì§€ ì¼€ì´ìŠ¤", "expected": "..."}},
            {{"input": "ì„±ëŠ¥ í…ŒìŠ¤íŠ¸", "expected": "..."}}
        ]
    }},
    ...
]

**ì¤‘ìš”**: ë°˜ë“œì‹œ ìœ íš¨í•œ JSON ë°°ì—´ë¡œ ì¶œë ¥í•˜ì„¸ìš”."""

        response = await self.llm.ainvoke([HumanMessage(content=prompt)])

        try:
            problems_data = json.loads(response.content)
            problems = [Problem(**p) for p in problems_data]
            logger.info(f"Generated {len(problems)} advanced problems")
            return problems
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON: {e}")
            return []

advanced_generator = AdvancedProblemGenerator()
```

---

## Week 2: ê²€ì¦ ë° ì™„ì„±

### Day 6-7: ë¬¸ì œ ê²€ì¦ ë° LangGraph ì›Œí¬í”Œë¡œìš°

**4.1 ë¬¸ì œ ê²€ì¦ê¸°**

```python
# validators/problem_validator.py
from models import Problem
from typing import List, Tuple
import logging

logger = logging.getLogger(__name__)

class ProblemValidator:
    """ìƒì„±ëœ ë¬¸ì œ ê²€ì¦"""

    def validate(self, problem: Problem, difficulty: str) -> Tuple[bool, str]:
        """ë¬¸ì œ ìœ íš¨ì„± ê²€ì¦"""

        # 1. í•„ìˆ˜ í•„ë“œ ê²€ì¦
        if not problem.question or len(problem.question) < 50:
            return False, "Question too short (minimum 50 characters)"

        if not problem.answer or len(problem.answer) < 20:
            return False, "Answer too short (minimum 20 characters)"

        if len(problem.hints) < 2:
            return False, "Need at least 2 hints"

        # 2. ë‚œì´ë„ ì ìˆ˜ ê²€ì¦
        difficulty_ranges = {
            "BEGINNER": (1, 3),
            "INTERMEDIATE": (4, 6),
            "ADVANCED": (7, 10)
        }

        min_score, max_score = difficulty_ranges[difficulty]
        if not (min_score <= problem.difficulty_score <= max_score):
            return False, f"Difficulty score must be between {min_score}-{max_score}"

        # 3. ì½”ë”© ë¬¸ì œ ê²€ì¦
        if problem.problem_type == "CODING":
            if not problem.test_cases or len(problem.test_cases) == 0:
                return False, "CODING problems need test cases"

            # í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ êµ¬ì¡° ê²€ì¦
            for tc in problem.test_cases:
                if 'input' not in tc or 'expected' not in tc:
                    return False, "Test case needs 'input' and 'expected' fields"

        # 4. ë‹µë³€ í’ˆì§ˆ ê²€ì¦
        if "TODO" in problem.answer or "..." in problem.answer:
            return False, "Answer contains placeholder text"

        return True, "Valid"

    def filter_valid_problems(
        self,
        problems: List[Problem],
        difficulty: str
    ) -> Tuple[List[Problem], List[str]]:
        """ìœ íš¨í•œ ë¬¸ì œë§Œ í•„í„°ë§"""

        valid_problems = []
        rejection_reasons = []

        for problem in problems:
            is_valid, reason = self.validate(problem, difficulty)

            if is_valid:
                valid_problems.append(problem)
                logger.info(f"âœ… Valid problem: {problem.question[:50]}...")
            else:
                rejection_reasons.append(reason)
                logger.warning(f"âŒ Rejected: {reason}")

        return valid_problems, rejection_reasons

problem_validator = ProblemValidator()
```

**4.2 LangGraph ì›Œí¬í”Œë¡œìš° êµ¬ì„±**

```python
# workflow.py
from langgraph.graph import StateGraph, START, END
from typing import TypedDict, List, Dict
from models import Problem
from utils.content_analyzer import content_analyzer
from generators.context_builder import context_builder
from generators.beginner import beginner_generator
from generators.intermediate import intermediate_generator
from generators.advanced import advanced_generator
from validators.problem_validator import problem_validator
import logging

logger = logging.getLogger(__name__)

class ProblemState(TypedDict):
    material_id: int
    difficulty: str
    problem_count: int
    learning_content: Dict
    context: str
    generated_problems: List[Problem]
    validated_problems: List[Problem]
    rejection_reasons: List[str]

# ë…¸ë“œ 1: í•™ìŠµ ë‚´ìš© ë¶„ì„
async def analyze_content_node(state: ProblemState) -> dict:
    """í•™ìŠµìë£Œì—ì„œ í•µì‹¬ ë‚´ìš© ì¶”ì¶œ"""
    material_id = state["material_id"]
    difficulty = state["difficulty"]

    logger.info(f"Analyzing content for {difficulty} problems")

    # í•™ìŠµ ë‚´ìš© ë¶„ì„
    analysis = await content_analyzer.analyze_material(
        material_id=material_id,
        difficulty=difficulty
    )

    return {"learning_content": analysis}

# ë…¸ë“œ 2: ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
async def build_context_node(state: ProblemState) -> dict:
    """ë¬¸ì œ ìƒì„±ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±"""
    learning_content = state["learning_content"]
    difficulty = state["difficulty"]

    documents = learning_content["documents"]

    # ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
    context = context_builder.build_context(
        documents=documents,
        difficulty=difficulty
    )

    logger.info(f"Built context: {len(context)} characters")

    return {"context": context}

# ë…¸ë“œ 3: ë¬¸ì œ ìƒì„±
async def generate_problems_node(state: ProblemState) -> dict:
    """ë‚œì´ë„ë³„ ë¬¸ì œ ìƒì„±"""
    difficulty = state["difficulty"]
    context = state["context"]
    problem_count = state["problem_count"]

    logger.info(f"Generating {problem_count} {difficulty} problems")

    # ë‚œì´ë„ë³„ ìƒì„±ê¸° ì„ íƒ
    if difficulty == "BEGINNER":
        problems = await beginner_generator.generate(context, problem_count)
    elif difficulty == "INTERMEDIATE":
        problems = await intermediate_generator.generate(context, problem_count)
    else:  # ADVANCED
        problems = await advanced_generator.generate(context, problem_count)

    return {"generated_problems": problems}

# ë…¸ë“œ 4: ë¬¸ì œ ê²€ì¦
async def validate_problems_node(state: ProblemState) -> dict:
    """ìƒì„±ëœ ë¬¸ì œ ê²€ì¦ ë° í•„í„°ë§"""
    problems = state["generated_problems"]
    difficulty = state["difficulty"]

    logger.info(f"Validating {len(problems)} problems")

    # ê²€ì¦
    validated_problems, rejection_reasons = problem_validator.filter_valid_problems(
        problems=problems,
        difficulty=difficulty
    )

    logger.info(f"Validated: {len(validated_problems)}/{len(problems)} problems")

    return {
        "validated_problems": validated_problems,
        "rejection_reasons": rejection_reasons
    }

# ë…¸ë“œ 5: ì¬ìƒì„± íŒë‹¨
def should_regenerate(state: ProblemState) -> str:
    """ë¬¸ì œê°€ ë¶€ì¡±í•˜ë©´ ì¬ìƒì„±"""
    validated_count = len(state["validated_problems"])
    required_count = state["problem_count"]

    if validated_count < required_count:
        logger.warning(f"Only {validated_count}/{required_count} problems valid. Regenerating...")
        return "regenerate"
    else:
        return "end"

# ì›Œí¬í”Œë¡œìš° ìƒì„±
def create_problem_workflow():
    graph = StateGraph(ProblemState)

    # ë…¸ë“œ ì¶”ê°€
    graph.add_node("analyze", analyze_content_node)
    graph.add_node("build_context", build_context_node)
    graph.add_node("generate", generate_problems_node)
    graph.add_node("validate", validate_problems_node)

    # ì—£ì§€
    graph.add_edge(START, "analyze")
    graph.add_edge("analyze", "build_context")
    graph.add_edge("build_context", "generate")
    graph.add_edge("generate", "validate")

    # ì¡°ê±´ë¶€ ì—£ì§€ (ì¬ìƒì„± íŒë‹¨)
    graph.add_conditional_edges(
        "validate",
        should_regenerate,
        {
            "regenerate": "generate",  # ë‹¤ì‹œ ìƒì„±
            "end": END
        }
    )

    return graph.compile()

problem_workflow = create_problem_workflow()
```

---

### Day 8-9: API êµ¬í˜„ ë° í…ŒìŠ¤íŠ¸

**5.1 FastAPI ì—”ë“œí¬ì¸íŠ¸**

```python
# api.py
from fastapi import APIRouter, HTTPException
from models import ProblemRequest, ProblemResponse
from workflow import problem_workflow
import logging

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/problems", tags=["Problems"])

@router.post("/generate", response_model=ProblemResponse)
async def generate_problems(request: ProblemRequest):
    """ë‚œì´ë„ë³„ ì‹¤ìŠµ ë¬¸ì œ ìƒì„±"""

    logger.info(
        f"Generating {request.problem_count} {request.difficulty} problems "
        f"for material {request.material_id}"
    )

    try:
        # LangGraph ì›Œí¬í”Œë¡œìš° ì‹¤í–‰
        result = await problem_workflow.ainvoke({
            "material_id": request.material_id,
            "difficulty": request.difficulty,
            "problem_count": request.problem_count
        })

        validated_problems = result["validated_problems"]
        rejection_reasons = result["rejection_reasons"]

        if not validated_problems:
            raise HTTPException(
                status_code=500,
                detail="Failed to generate valid problems"
            )

        return ProblemResponse(
            problems=validated_problems,
            difficulty=request.difficulty,
            generated_count=len(validated_problems),
            rejected_count=len(rejection_reasons)
        )

    except Exception as e:
        logger.error(f"Error generating problems: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/difficulties")
async def get_difficulty_info():
    """ë‚œì´ë„ë³„ ì •ë³´ ì¡°íšŒ"""
    return {
        "BEGINNER": {
            "score_range": "1-3",
            "description": "ê¸°ë³¸ ê°œë… ì´í•´ í™•ì¸",
            "example": "JPA Entity í´ë˜ìŠ¤ ì‘ì„±í•˜ê¸°"
        },
        "INTERMEDIATE": {
            "score_range": "4-6",
            "description": "ì‹¤ë¬´ ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜ ì‹¤ìŠµ",
            "example": "ê²Œì‹œíŒ CRUD API êµ¬í˜„í•˜ê¸°"
        },
        "ADVANCED": {
            "score_range": "7-10",
            "description": "ë³µì¡í•œ ì„¤ê³„ ë° ìµœì í™”",
            "example": "ëŒ€ìš©ëŸ‰ íŠ¸ë˜í”½ì„ ìœ„í•œ ìºì‹± ì „ëµ ì„¤ê³„"
        }
    }
```

**5.2 í†µí•© í…ŒìŠ¤íŠ¸**

```python
# tests/test_problem_generation.py
import asyncio
from workflow import problem_workflow

async def test_problem_generation():
    """ë¬¸ì œ ìƒì„± ì „ì²´ í…ŒìŠ¤íŠ¸"""

    difficulties = ["BEGINNER", "INTERMEDIATE", "ADVANCED"]

    for difficulty in difficulties:
        print(f"\n{'='*50}")
        print(f"Testing {difficulty} problem generation")
        print('='*50)

        result = await problem_workflow.ainvoke({
            "material_id": 1,
            "difficulty": difficulty,
            "problem_count": 3
        })

        problems = result["validated_problems"]

        print(f"\nâœ… Generated {len(problems)} valid problems")

        for i, problem in enumerate(problems, 1):
            print(f"\n[ë¬¸ì œ {i}]")
            print(f"ë‚œì´ë„ ì ìˆ˜: {problem.difficulty_score}")
            print(f"ìœ í˜•: {problem.problem_type}")
            print(f"ì§ˆë¬¸: {problem.question[:100]}...")
            print(f"íŒíŠ¸ ê°œìˆ˜: {len(problem.hints)}")
            print(f"í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤: {len(problem.test_cases)}")

        print(f"\nâŒ Rejected: {len(result['rejection_reasons'])} problems")
        for reason in result['rejection_reasons']:
            print(f"  - {reason}")

if __name__ == "__main__":
    asyncio.run(test_problem_generation())
```

```bash
# ì‹¤í–‰
python tests/test_problem_generation.py
```

---

### Day 10: ë¬¸ì„œí™” ë° ì™„ì„±

**6.1 ë©”ì¸ ì„œë²„ íŒŒì¼**

```python
# main.py
from fastapi import FastAPI
from api import router
import logging

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

app = FastAPI(
    title="EduMentor Problem Generation API",
    description="ë‚œì´ë„ë³„ ì‹¤ìŠµ ë¬¸ì œ ìë™ ìƒì„± ì‹œìŠ¤í…œ",
    version="1.0.0"
)

app.include_router(router)

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "problem-generation"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)
```

**6.2 README ì‘ì„±**

```markdown
# íŒ€2: ì‹¤ìŠµ ë¬¸ì œ ìƒì„± ì‹œìŠ¤í…œ

## ê°œìš”

í•™ìŠµìë£Œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‚œì´ë„ë³„(ì´ˆê¸‰/ì¤‘ê¸‰/ê³ ê¸‰) ì‹¤ìŠµ ë¬¸ì œë¥¼ ìë™ ìƒì„±í•©ë‹ˆë‹¤.

## ì„¤ì¹˜

```bash
pip install -r requirements.txt
```

## ì‹¤í–‰

```bash
# íŒ€1 ì„œë²„ê°€ ë¨¼ì € ì‹¤í–‰ë˜ì–´ ìˆì–´ì•¼ í•¨ (ChromaDB ì—°ë™)
python main.py
```

ì„œë²„: http://localhost:8001

## API ì‚¬ìš©ë²•

### 1. ì´ˆê¸‰ ë¬¸ì œ ìƒì„±

```bash
curl -X POST http://localhost:8001/problems/generate \
  -H "Content-Type: application/json" \
  -d '{
    "material_id": 1,
    "difficulty": "BEGINNER",
    "problem_count": 3
  }'
```

### 2. ì¤‘ê¸‰ ë¬¸ì œ ìƒì„±

```bash
curl -X POST http://localhost:8001/problems/generate \
  -H "Content-Type: application/json" \
  -d '{
    "material_id": 1,
    "difficulty": "INTERMEDIATE",
    "problem_count": 3
  }'
```

### 3. ê³ ê¸‰ ë¬¸ì œ ìƒì„±

```bash
curl -X POST http://localhost:8001/problems/generate \
  -H "Content-Type: application/json" \
  -d '{
    "material_id": 1,
    "difficulty": "ADVANCED",
    "problem_count": 3
  }'
```

## ë¬¸ì œ êµ¬ì¡°

```json
{
  "question": "ë¬¸ì œ ë‚´ìš©",
  "answer": "ì •ë‹µ",
  "hints": ["íŒíŠ¸1", "íŒíŠ¸2"],
  "difficulty_score": 5,
  "problem_type": "CODING",
  "test_cases": [
    {"input": "ì…ë ¥", "expected": "ê¸°ëŒ€ ì¶œë ¥"}
  ]
}
```

## ë‚œì´ë„ ê¸°ì¤€

| ë‚œì´ë„ | ì ìˆ˜ | ì„¤ëª… |
|--------|------|------|
| BEGINNER | 1-3 | ê¸°ë³¸ ê°œë…, ê°„ë‹¨í•œ ì½”ë“œ (5-10ì¤„) |
| INTERMEDIATE | 4-6 | ì‹¤ë¬´ ì‹œë‚˜ë¦¬ì˜¤, ì¤‘ê°„ ì½”ë“œ (20-30ì¤„) |
| ADVANCED | 7-10 | ë³µì¡í•œ ì„¤ê³„, ìµœì í™” ê³ ë ¤ |

## ê²€ì¦ ê·œì¹™

- ì§ˆë¬¸ ìµœì†Œ 50ì
- ë‹µë³€ ìµœì†Œ 20ì
- íŒíŠ¸ 2ê°œ ì´ìƒ
- ì½”ë”© ë¬¸ì œëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ í•„ìˆ˜
---
## ğŸ“Š íŒ€2 ì™„ì„± ì²´í¬ë¦¬ìŠ¤íŠ¸

### í•µì‹¬ ê¸°ëŠ¥
- [ ] í•™ìŠµ ë‚´ìš© ë¶„ì„ (ChromaDB ê²€ìƒ‰)
- [ ] ë‚œì´ë„ë³„ ë¬¸ì œ ìƒì„± (ì´ˆê¸‰/ì¤‘ê¸‰/ê³ ê¸‰)
- [ ] ë¬¸ì œ ê²€ì¦ ì‹œìŠ¤í…œ
- [ ] LangGraph ì›Œí¬í”Œë¡œìš°
- [ ] ì¬ìƒì„± ë¡œì§ (ê²€ì¦ ì‹¤íŒ¨ ì‹œ)

### ë¬¸ì œ ìœ í˜•
- [ ] ì½”ë”© ë¬¸ì œ (CODING)
- [ ] ì„œìˆ í˜• ë¬¸ì œ (SHORT_ANSWER)
- [ ] í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìƒì„±

### API ì—”ë“œí¬ì¸íŠ¸
- [ ] POST `/problems/generate` - ë¬¸ì œ ìƒì„±
- [ ] GET `/problems/difficulties` - ë‚œì´ë„ ì •ë³´

### ê²€ì¦ í•­ëª©
- [ ] ì§ˆë¬¸ ê¸¸ì´ (ìµœì†Œ 50ì)
- [ ] ë‹µë³€ ê¸¸ì´ (ìµœì†Œ 20ì)
- [ ] íŒíŠ¸ ê°œìˆ˜ (ìµœì†Œ 2ê°œ)
- [ ] ë‚œì´ë„ ì ìˆ˜ ê²€ì¦
- [ ] í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ê²€ì¦

### í…ŒìŠ¤íŠ¸
- [ ] ë‚œì´ë„ë³„ ë¬¸ì œ ìƒì„± í…ŒìŠ¤íŠ¸
- [ ] ê²€ì¦ ë¡œì§ í…ŒìŠ¤íŠ¸
- [ ] ì¬ìƒì„± ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

### ë¬¸ì„œí™”
- [ ] API ë¬¸ì„œ (FastAPI Swagger)
- [ ] README.md
- [ ] ì½”ë“œ ì£¼ì„

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

íŒ€2 ì™„ë£Œ í›„:
1. **íŒ€1ê³¼ í†µí•©**: Spring Boot ì—°ë™
2. **ì „ì²´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸**: QA + ë¬¸ì œ ìƒì„± í†µí•©
3. **UI ê°œë°œ**: ë¬¸ì œ í‘œì‹œ ë° ì œì¶œ í™”ë©´
4. **ë°°í¬ ì¤€ë¹„**: Docker ì»¨í…Œì´ë„ˆí™”

---

**ì‘ì„±ì¼**: 2025-10-28
**ë‹´ë‹¹**: íŒ€2 (ê°œë°œì C, D)
